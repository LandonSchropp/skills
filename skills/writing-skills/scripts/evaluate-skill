#!/usr/bin/env ruby
# frozen_string_literal: true

require 'json'
require 'optparse'
require 'yaml'
require_relative 'commands'

# This script implements a mini evaluation harness designed to test Claude Code Skills.
#
# It can run multiple scenarios across several iterations, measures skill invocation and execution
# success, stores results for analysis, and compare performance against expected thresholds.
#
# This evaluation harness is designed to accommodate a few primary use cases:
#
# - Skill validation: Determine if a skill works well enough to ship. Set thresholds like "skill
#   should be invoked 80% of the time" and "should succeed 70% of the time when invoked."
# - Self-improvement: Let an agent run the harness against its own skills, see what's failing, and
#   iterate on descriptions and prompts.
# - Experimentation: Compare variants (different AGENTS.md files, different models, different skill
#   descriptions) to see what actually improves performance.

DEFAULT_NUMBER_OF_RUNS = 3

def log(scenario_number, message)
  $stderr.puts "\033[35m[evaluate-skill] - Scenario #{scenario_number} - #{message}\033[0m"
end

def evaluate_skill_scenario(script_path, task, scenario_number, run_number, expected_skills, unexpected_skills, expected_results, no_plugin)
  command = [
    script_path,
    '--task', task,
    '--scenario-number', scenario_number.to_s,
    '--run-number', run_number.to_s
  ]

  expected_skills.each do |skill|
    command.concat(['--expected-skill', skill])
  end

  unexpected_skills.each do |skill|
    command.concat(['--unexpected-skill', skill])
  end

  expected_results.each do |result|
    command.concat(['--expected-result', result])
  end

  command << '--no-plugin' if no_plugin

  output, exit_status = run_command(command, json: true, stream_stderr: false, timeout: 600)

  if exit_status != 0
    raise "evaluate-skill-scenario failed with exit code #{exit_status}"
  end

  output
end

options = {
  number_of_runs: DEFAULT_NUMBER_OF_RUNS,
  no_plugin: false,
  scenarios: []
}

parser = OptionParser.new do |opts|
  opts.summary_indent = ""
  opts.banner = "Usage: evaluate-skill --yaml-file <file> [OPTIONS]"
  opts.separator ""
  opts.separator "Runs all test scenarios from a SKILL.test.yml file and displays results."
  opts.separator ""
  opts.separator "Required Arguments:"
  opts.separator ""

  opts.on("--yaml-file <file>", "Path to the YAML file containing test scenarios") do
    options[:yaml_file] = _1
  end

  opts.separator ""
  opts.separator "Options:"
  opts.separator ""

  opts.on("--number-of-runs <number>", Integer, "Number of times to run each scenario (default: #{DEFAULT_NUMBER_OF_RUNS})") do
    options[:number_of_runs] = _1
  end

  opts.on("--pass-threshold <rate>", Float, "Pass rate threshold (default: (number_of_runs - 1) / number_of_runs)") do
    options[:pass_threshold] = _1
  end

  opts.on("--scenario <number>", Integer, "Run specific scenario number (can be specified multiple times)") do
    options[:scenarios] << _1
  end

  opts.on("--no-plugin", "Disables the plugin directory (no skills available)") do
    options[:no_plugin] = true
  end

  opts.on("--help", "Displays the usage information.") do
    puts opts
    exit 0
  end

  opts.separator ""
  opts.separator "Examples:"
  opts.separator ""
  opts.separator '    evaluate-skill --yaml-file SKILL.test.yml'
  opts.separator '    evaluate-skill --yaml-file SKILL.test.yml --number-of-runs 10 --pass-threshold 0.9'
  opts.separator '    evaluate-skill --yaml-file SKILL.test.yml --scenario 1 --scenario 3'
end

parser.parse!

if options[:yaml_file].nil?
  $stderr.puts "Error: --yaml-file is required"
  $stderr.puts ""
  $stderr.puts parser
  exit 1
end

yaml_file = options[:yaml_file]
number_of_runs = options[:number_of_runs]
pass_threshold = options[:pass_threshold] || ((number_of_runs - 1).to_f / number_of_runs)

unless File.exist?(yaml_file)
  $stderr.puts "Error: #{yaml_file} not found"
  exit 1
end

yaml_content = YAML.load_file(yaml_file)
scenarios = yaml_content['scenarios']

unless scenarios && scenarios.is_a?(Array)
  $stderr.puts "Error: YAML file must contain a 'scenarios' array"
  exit 1
end

# Filter scenarios if specific scenario numbers were provided
scenario_entries = if options[:scenarios].empty?
  # Run all scenarios with their original numbers (1-indexed)
  scenarios.map.with_index(1) { |scenario, index| [index, scenario] }
else
  scenario_numbers = options[:scenarios].sort.uniq

  # Validate that all requested scenarios exist
  invalid_scenarios = scenario_numbers.select { |n| n < 1 || n > scenarios.size }
  unless invalid_scenarios.empty?
    $stderr.puts "Error: Invalid scenario number(s): #{invalid_scenarios.join(', ')}"
    $stderr.puts "Valid scenario numbers are 1-#{scenarios.size}"
    exit 1
  end

  # Filter to only the requested scenarios, preserving original numbers
  scenario_numbers.map { |n| [n, scenarios[n - 1]] }
end

script_directory = File.dirname(__FILE__)
evaluate_scenario_script = File.join(script_directory, 'evaluate-skill-scenario')

# Spawn all runs for all scenarios in parallel
all_scenario_data = scenario_entries.map do |scenario_number, scenario|
  scenario_title = scenario['scenario']
  task = scenario['task']
  expected_skills = scenario['expected_skills'] || []
  unexpected_skills = scenario['unexpected_skills'] || []
  expected_results = scenario['expected_results'] || []

  log(scenario_number, "Starting #{number_of_runs} run#{number_of_runs > 1 ? 's' : ''}")

  threads = (1..number_of_runs).map do |run_number|
    Thread.new do
      begin
        evaluate_skill_scenario(
          evaluate_scenario_script,
          task,
          scenario_number,
          run_number,
          expected_skills,
          unexpected_skills,
          expected_results,
          options[:no_plugin]
        )
      rescue => e
        log(scenario_number, "Run #{run_number} failed: #{e.message}")
        nil
      end
    end
  end

  {
    scenario_number: scenario_number,
    scenario_title: scenario_title,
    threads: threads,
    expected_skills: expected_skills,
    unexpected_skills: unexpected_skills,
    expected_results: expected_results
  }
end

# Wait for all threads to complete and compile results
all_scenario_data.each do |data|
  scenario_number = data[:scenario_number]
  scenario_title = data[:scenario_title]
  expected_skills = data[:expected_skills]
  unexpected_skills = data[:unexpected_skills]
  expected_results = data[:expected_results]

  results = data[:threads].map(&:value).compact

  if results.empty?
    log(scenario_number, "Error: All runs failed")
    next
  end

  log(scenario_number, "Completed #{results.size}/#{number_of_runs} runs successfully")

  # Compile results
  expected_skills_summary = expected_skills.to_h do |expected_skill|
    passes = results.count do |result|
      result['expected_skills'].find do |skill_result|
        skill_result['skill'] == expected_skill && skill_result['status'] == 'PASS'
      end
    end

    [expected_skill, { passed: passes, total: results.size }]
  end

  unexpected_skills_summary = unexpected_skills.to_h do |unexpected_skill|
    passes = results.count do |result|
      result['unexpected_skills'].find do |skill_result|
        skill_result['skill'] == unexpected_skill && skill_result['status'] == 'PASS'
      end
    end

    [unexpected_skill, { passed: passes, total: results.size }]
  end

  expected_results_summary = expected_results.to_h do |expected_result|
    passes = results.count do |result|
      result['expected_results'].find do |expectation_result|
        expectation_result['expectation'] == expected_result && expectation_result['status'] == 'PASS'
      end
    end

    [expected_result, { passed: passes, total: results.size }]
  end

  # Display results
  puts "#{scenario_number}. #{scenario_title}"

  # Skills
  unless expected_skills.empty?
    expected_skills.each do |skill|
      summary = expected_skills_summary[skill]
      pass_rate = summary[:passed].to_f / summary[:total]
      percentage = (pass_rate * 100).round
      status_symbol = pass_rate >= pass_threshold ? '✓' : '×'
      puts "   #{status_symbol} #{percentage.to_s.rjust(3)}% Expected skill: #{skill} (#{summary[:passed]}/#{summary[:total]} passed)"
    end
  end

  unless unexpected_skills.empty?
    unexpected_skills.each do |skill|
      summary = unexpected_skills_summary[skill]
      pass_rate = summary[:passed].to_f / summary[:total]
      percentage = (pass_rate * 100).round
      status_symbol = pass_rate >= pass_threshold ? '✓' : '×'
      puts "   #{status_symbol} #{percentage.to_s.rjust(3)}% Unexpected skill: #{skill} (#{summary[:passed]}/#{summary[:total]} not invoked)"
    end
  end

  # Expected results
  unless expected_results.empty?
    expected_results.each do |result_text|
      summary = expected_results_summary[result_text]
      pass_rate = summary[:passed].to_f / summary[:total]
      percentage = (pass_rate * 100).round
      status_symbol = pass_rate >= pass_threshold ? '✓' : '×'
      puts "   #{status_symbol} #{percentage.to_s.rjust(3)}% #{result_text} (#{summary[:passed]}/#{summary[:total]} passed)"
    end
  end

  puts ""
end
